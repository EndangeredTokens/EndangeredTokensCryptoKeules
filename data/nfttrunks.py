# -*- coding: utf-8 -*-
"""NFTTrunks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Pd6XNS-8pmnrl23ubR2-53LZxFQARKd

#Importación archivos base
"""

!wget -q -O file.zip "https://drive.google.com/uc?export=download&id=1Ou29Ih4kcF-rindOk3Zvxxdzzk4V4rbJ"
!unzip -q file.zip

from google.colab import drive
drive.mount('/content/drive')

from layer1 import layer1
from layer2 import layer2
from layer3 import layer3
from layer4 import layer4
from layer5 import layer5
from layer6 import layer6
from layer7 import layer7
from layer8 import layer8
from layer9 import layer9
from layer10 import layer10

layers = [
  list(layer1.keys()),
  list(layer2.keys()),
  list(layer3.keys()),
  list(layer4.keys()),
  list(layer5.keys()),
  list(layer6.keys()),
  list(layer7.keys()),
  list(layer8.keys()),
  list(layer9.keys()),
  list(layer10.keys())
]
allinfo = [
  layer1,
  layer2,
  layer3,
  layer4,
  layer5,
  layer6,
  layer7,
  layer8,
  layer9,
  layer10
]
name_layers = ["Background Color", "Background Elements", "Soil type", "Roots elements", "Body", "Branches", "Animal", "Liana", "Extras", "Fruit"]

if len(name_layers) != len(layers): print('ERROR: LAS LISTAS DEBEN TENER EL MISMO TAMAÑO')

"""#Calculo todas las combinatorias"""

def build_image(layers: list):
    meta_image_list = []
    prob_image_list = []
    length_layers = len(layers)-1

    def recursive(base_layer, base_prob,layers_index):
        layer_index = 0
        length_layer = len(layers[layers_index])
        while layer_index < length_layer:
            meta_image = base_layer.copy()
            prob_image = base_prob.copy()
            layer = allinfo[layers_index][layers[layers_index][layer_index]]
            meta_image.append(layers[layers_index][layer_index])
            prob_image.append(layer['prob'])
            restrictions = layer['prev']
            if len(meta_image) > 0 and len(restrictions) > 0:
                for restriction in restrictions:
                    if restriction in meta_image:
                        meta_image.pop(-1)
            if layers_index == length_layers:
                if len(meta_image) == length_layers + 1:
                    meta_image_list.append(meta_image)
                    prob_image_list.append(prob_image)
            else:
                recursive(meta_image, prob_image,layers_index+1)
            layer_index += 1
    recursive([],[], 0)
    return  meta_image_list, prob_image_list

meta_image_combinations, probability_imagebylayer_combinations = build_image(layers)

"""#Calculo de probabilidades de cada combinatoria"""

probability_image_combinations = []
for index_image, image in enumerate(meta_image_combinations):
    probability = 1
    for index_layer, layer in enumerate(image):
      probability = probability * probability_imagebylayer_combinations[index_image][index_layer]
    probability_image_combinations.append(probability)

"""#Remover las imagenes con probabilidad 0"""

meta_image_combinations_zeroless = []
probability_image_combinations_zeroless = []
for index_probability, probability in enumerate(probability_image_combinations):
  if probability != 0:
    probability_image_combinations_zeroless.append(probability)
    meta_image_combinations_zeroless.append(meta_image_combinations[index_probability])

"""Crear los requerimientos para luego obtener todos ellos de una manera random y despues rellenar los faltantes random. Ej. Necesito 1000 noches y 500 arcoiris y generar un total de 5000 imagenes, el codigo eligira 1000 noches y 500 arcoiris y despues eligira las 3500 restantes de una manera aleatoria."""

requirement_dict = {}
for index, layer in enumerate(allinfo):
  for name in layer.keys():
    if 'selection' in layer[name]:
      requirement_dict[f'{index}_{name}'] = int(layer[name]['prob']*9990)

import random 

requirement_dict_copy = requirement_dict.copy()
meta_image_combinations_zeroless_copy = meta_image_combinations_zeroless.copy()
meta_image_selection = []

for requirements in list(reversed(list(requirement_dict_copy.keys()))):
  while requirement_dict_copy[requirements] > 0:
    choice = random.randint(0, len(meta_image_combinations_zeroless_copy)-1)
    choice_image = meta_image_combinations_zeroless_copy[choice]
    limit = False
    hasitem = False
    for index, layer in enumerate(choice_image):
      if f'{index}_{layer}' == requirements:
        hasitem = True
      if f'{index}_{layer}' in requirement_dict_copy and requirement_dict_copy[f'{index}_{layer}'] == 0:
        limit = True
        meta_image_combinations_zeroless_copy.pop(choice)
        break
    if limit == True or hasitem == False: continue
    for index, layer in enumerate(choice_image):
      if f'{index}_{layer}' in requirement_dict_copy:
        requirement_dict_copy[f'{index}_{layer}'] = requirement_dict_copy[f'{index}_{layer}'] - 1
    meta_image_selection.append(choice_image)
    meta_image_combinations_zeroless_copy.pop(choice)

import random 

meta_image_combinations_zeroless_copy = meta_image_combinations_zeroless.copy()
forbidden = list(requirement_dict.keys())

while len(meta_image_selection) < 9989:
  choice = random.randint(0, len(meta_image_combinations_zeroless_copy)-1)
  choice_image = meta_image_combinations_zeroless_copy[choice]
  has_forbidden = False
  for index, layer in enumerate(choice_image):
    if f'{index}_{layer}' in forbidden:
      has_forbidden = True
      meta_image_combinations_zeroless_copy.pop(choice)
      break
  if has_forbidden == True: continue
  meta_image_selection.append(choice_image)
  meta_image_combinations_zeroless_copy.pop(choice)

"""#Verificar que las reglas se cumplieron"""

for rule in forbidden:
  typevar = 0
  for index_image, image in enumerate(meta_image_selection):
    for index_layer, layer in enumerate(image):
      if f'{index_layer}_{layer}' == rule:
        typevar += 1
        break
  print(f'{rule}: {typevar}', end=" --> ")
  if requirement_dict[f'{rule}'] == typevar: print('OK')

"""#Creación de imagenes"""

meta_image_sub_selection = meta_image_selection

import os
dirname = '/content/base_images'
for layer in allinfo:
  for attribute in layer.values():
    if os.path.exists(f'{dirname}/{attribute["file"]}') == False:
      print(f'Error: file {dirname}/{attribute["file"]} does not exist')

!rm -r results
!mkdir results

#Comentar esta linea para crear las totas las imagenes y no solo una muestra.
# meta_image_sub_selection = meta_image_selection[::100]

random_name_list = list(range(1, len(meta_image_sub_selection)+2))
name_list = []

from PIL import Image
image_base = None
for index_meta_image, meta_image in enumerate(meta_image_sub_selection):
  if index_meta_image % 100 == 0: print(index_meta_image)
  for index_layer, layer in enumerate(meta_image):
    if allinfo[index_layer][layer]["file"] == '':
      continue
    if image_base == None:
      image_base = Image.open(f'{dirname}/{allinfo[index_layer][layer]["file"]}')
      image_base = image_base.convert("RGBA")
      continue
    image_actual = Image.open(f'{dirname}/{allinfo[index_layer][layer]["file"]}')
    image_actual = image_actual.convert("RGBA")
    image_base.paste(image_actual, (0,0), mask=image_actual)
  random_name = random.choice(random_name_list)
  random_name_list.remove(random_name)
  image_base.save(f'results/{random_name}.png')
  name_list.append(random_name)

"""#Creación de los JSON"""

!rm -r results_json
!mkdir results_json

import json

file = open('base.json')
base_json = json.load(file)

for index_meta_image , meta_image in enumerate(meta_image_sub_selection):
  if index_meta_image % 100 == 0: print(index_meta_image)
  base_json_image = base_json.copy()
  base_json_image['name'] = f'CryptoKeule #{name_list[index_meta_image]}'
  base_json_image['attributes'].clear()
  base_json_image['attributes'].append({"trait_type": "NFTrunk code","value": f"CK{name_list[index_meta_image]}"})
  base_json_image['attributes'].append({"trait_type": "CryptoKeule Code","value": name_list[index_meta_image]})
  for index_layer, layer in enumerate(meta_image):
    base_json_image['attributes'].append({"trait_type": name_layers[index_layer],"value": layer})
  with open(f'results_json/{name_list[index_meta_image]}.json', 'w') as outfile:
      json.dump(base_json_image, outfile)
  outfile.close()

"""#Conectar a tu Google Drive y mover los resultados para alla. 
Tanto los png como los JSON
"""

from google.colab import drive

drive.mount("/content/gdrive")

!cp -r results gdrive/MyDrive/
!cp -r results_json gdrive/MyDrive/